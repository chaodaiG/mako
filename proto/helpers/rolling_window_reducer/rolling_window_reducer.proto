// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// -----------------------------------------------------------------------------
// Rolling Window Reducer
// -----------------------------------------------------------------------------
//
// The Rolling Window Reducer is a library that allows you to smoothen
// predownsampled data or extract aggregate data from it.
//
// It works similarly to a rolling average. A window moves from the first point
// to the last point in your data set with a step size specified in the
// RWRConfig protobuf. For each step we perform the calculation specified (eg.
// sum, count or mean) on all the points within the window. A new SamplePoint
// with an input_value (x-val) as the middle of the window and a KeyedValue
// (y-value) as the window parameter the user is interested in is created.
//
// See https://github.com/google/mako/blob/master/docs/ROLLING_WINDOW_REDUCER.md
// for more information.

syntax = "proto2";

package mako.helpers;

import "spec/proto/mako.proto";

option java_package = "com.google.testing.performance.mako.helpers";
option java_outer_classname = "RollingWindowReducerProto";

// Passed into the RollingWindowReducer constructor
// NEXT ID: 13
message RWRConfig {
  // CONDITIONALLY REQUIRED
  // Metric value keys for the sample points you are interested in processing.
  // At least one key must be provided if not using any error (ERROR_*)
  // operation type.
  repeated string input_metric_keys = 1;

  // CONDITIONALLY REQUIRED
  // There must be at least one denominator metric key provided if using any
  // ratio (RATIO_*) WindowOperation type.
  // At least one key must be provided.
  repeated string denominator_input_metric_keys = 9;

  // CONDITIONALLY REQUIRED
  // Sampler names for the sample errors you are interested in processing.
  // At least one name must be provided if using any error (ERROR_*) operation
  // type.
  repeated string error_sampler_name_inputs = 10;

  // REQUIRED
  // Metric value key for output SamplePoints generated by the
  // RollingWindowReducer
  optional string output_metric_key = 2;

  enum WindowOperation {
    COUNT = 1;
    SUM = 2;
    MEAN = 3;
    PERCENTILE = 4;
    RATIO_SUM = 5;
    ERROR_COUNT = 6;
  }
  // REQUIRED
  // Operation you are interested in performing to compute each window's value
  //
  // Operation explanations:
  //   * COUNT
  //       Returns the number of points in each window.
  //       Useful for computing values such as QPS. If your samplers
  //       are configured to return a point (i.e. latency) after each
  //       query is executed, the count in each 1 second window represents
  //       the queries per second executed. Note, if the input_value of the
  //       SamplePoint is time in milliseconds, the window size should be 1000.
  //   * SUM
  //       Returns the sum of the points in each window.
  //       Useful for computing values such as throughput. If each sampler
  //       is returning its throughput, the sum of all throughputs in a window
  //       will provide you with the overall in a specific time interval.
  //   * MEAN
  //       Returns the mean of the points in each window.
  //       Useful for computing rolling averages of collected data. Allows you
  //       to process millions of erratic points for a specific value and
  //       extrapolate points which portray a general trend of how the value
  //       was changing over time.
  //   * PERCENTILE
  //       Returns the percentile specified by percentile_milli in each window.
  //   * RATIO_SUM
  //       Return the ratio between the sum of the points in each window for
  //       two specified metric keys. The first metric key in input_metric_keys
  //       is the numerator and the first metric key in
  //       denominator_input_metric_keys is the denominator.
  //       Allows you to calculate metrics like the ratio of errors to total
  //       requests processed for verifying that we are staying under the
  //       product's error SLO.
  //   * ERROR_COUNT
  //       Returns the number of errors in each window.
  optional WindowOperation window_operation = 3;

  // REQUIRED
  // The higher this value, the smoother the resulting data.
  // For computing throughput / aggregate data, this value does not need to be
  // the interval of time you are interested in; see output_scaling_factor.
  //
  // Each window is inclusive on the lower end and exclusive on the upper end
  // eg. [...)
  optional double window_size = 4;

  // REQUIRED
  // The number of steps per window
  // The higher this value, the more output points will be created (the
  // resulting data will have a greater resolution).
  //
  // The step size is the distance between each consecutive window.
  //   [___________win_1___________)
  //   <- step size ->[___________win_2___________)
  //
  // A lower step size increases the resolution of the output data.
  // steps_per_window is the number of steps that fit in a window.
  // More specifically, steps_per_window = window_size / step_size
  // Thus, increasing the steps_per_window increases the resolution of the
  // output data.
  //
  // We take steps_per_window as an input instead of step_size in order
  // to enforce that window size is evenly divisible by step size. This is
  // done to ensure that every input point is equally represented in
  // the output data.
  //
  // Note that because each output point is in the center of its window you may
  // see points created just less than the step_size before the first input
  // point.
  //
  //                             * (first input_point)
  //  [___________win_1___________)
  //               <- step size ->
  //               * (first output point)
  //
  optional int32 steps_per_window = 5 [default = 1];

  // REQUIRED
  // If a window is empty, should its value be omitted or be set to 0.
  // For a window_operation value of COUNT and SUM, this field should most
  // likely be set to true. For MEAN, it will should most likely be set to
  // false. This value is heavily dependant on your use case.
  optional bool zero_for_empty_window = 6;

  // CONDITIONALLY_REQUIRED if window_operation is PERCENTILE.
  // The 1000th percentile to calculate. e.g. 99000 calculates the 99th
  // percentile.
  optional int32 percentile_milli = 7;

  // UNCOMMON
  // When specified, the output value for each window will be multiplied by
  // this factor. This allows you to compute a rate without restricting
  // window_size (i.e. smoothness).
  // Another possible use is to adjust units, e.g. convert latency-in-seconds to
  // latency-in-milliseconds.
  //
  // For example, if window_operation is COUNT and input_value is milliseconds,
  // these all produce QPS outputs at varying levels of smoothness:
  //   * window_size = 1000 [output_scaling_factor = 1]  (default)
  //   * window_size = 5000, output_scaling_factor = 0.2 (more smooth)
  //   * window_size = 100,  output_scaling_factor = 10  (less smooth)
  //
  // Cannot be zero.
  optional double output_scaling_factor = 12 [default = 1];

  // UNCOMMON
  // Limits the sample size used per window for percentile operations, which
  // can help reduce memory usage when samples per window is large.
  // A value of -1 indicates no max.
  optional int32 max_sample_size = 8 [default = -1];

  // UNCOMMON.
  // Only applicable when window_operation is ERROR_COUNT. When specified, the
  // sampler error will only be counted if
  // RE2::PartialMatch(error_text, error_matcher) is true.
  optional string error_matcher = 11;
}

// Passed into the RollingWindowReducer ProcessPoints call
message RWRAddPointsInput {
  // REQUIRED
  // Repeated field of points to be processed
  repeated SamplePoint point_list = 1;

  // OPTIONAL
  // Repeated field of sample errors to be processed
  repeated SampleError error_list = 2;
}

// Passed into the RollingWindowReducer Complete call,
message RWRCompleteOutput {
  // REQUIRED
  // Repeated field of points resulting from RollingWindowReducer processing
  repeated SamplePoint point_list = 1;
}
